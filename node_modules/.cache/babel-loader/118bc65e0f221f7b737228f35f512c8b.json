{"ast":null,"code":"import { useState, useRef, useEffect, useCallback } from 'react';\nimport isEqual from 'lodash/isEqual';\n// thanks Kent C Dodds for the following helpers\nexport function useSafeSetState(initialState) {\n  var _a = useState(initialState),\n    state = _a[0],\n    setState = _a[1];\n  var mountedRef = useRef(false);\n  useEffect(function () {\n    mountedRef.current = true;\n    return function () {\n      mountedRef.current = false;\n    };\n  }, []);\n  var safeSetState = useCallback(function (args) {\n    if (mountedRef.current) {\n      return setState(args);\n    }\n  }, [mountedRef, setState]);\n  return [state, safeSetState];\n}\nexport function usePrevious(value) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = value;\n  });\n  return ref.current;\n}\nexport function useDeepCompareEffect(callback, inputs) {\n  var cleanupRef = useRef();\n  useEffect(function () {\n    if (!isEqual(previousInputs, inputs)) {\n      cleanupRef.current = callback();\n    }\n    return cleanupRef.current;\n  });\n  var previousInputs = usePrevious(inputs);\n}\n/**\n * A hook that returns true once a delay has expired.\n * @param ms The delay in milliseconds\n * @param key A key that can be used to reset the timer\n * @returns true if the delay has expired, false otherwise\n */\nexport function useTimeout(ms, key) {\n  if (ms === void 0) {\n    ms = 0;\n  }\n  if (key === void 0) {\n    key = '';\n  }\n  var _a = useSafeSetState(false),\n    ready = _a[0],\n    setReady = _a[1];\n  useEffect(function () {\n    setReady(false);\n    var timer = setTimeout(function () {\n      setReady(true);\n    }, ms);\n    return function () {\n      clearTimeout(timer);\n    };\n  }, [key, ms, setReady]);\n  return ready;\n}\nexport function useIsMounted() {\n  var isMounted = useRef(true);\n  useEffect(function () {\n    isMounted.current = true;\n    return function () {\n      isMounted.current = false;\n    };\n  }, []);\n  return isMounted;\n}","map":{"version":3,"sources":["../../../src/util/hooks.ts"],"names":[],"mappings":"AACA,SAAS,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,WAAW,QAAQ,OAAO;AAChE,OAAO,OAAO,MAAM,gBAAgB;AAEpC;AAEA,OAAM,SAAU,eAAe,CAC3B,YAA4B,EAAA;EAEtB,IAAA,EAAA,GAAoB,QAAQ,CAAC,YAAY,CAAC;IAAzC,KAAK,GAAA,EAAA,CAAA,CAAA,CAAA;IAAE,QAAQ,GAAA,EAAA,CAAA,CAAA,CAA0B;EAEhD,IAAM,UAAU,GAAG,MAAM,CAAC,KAAK,CAAC;EAChC,SAAS,CAAC,YAAA;IACN,UAAU,CAAC,OAAO,GAAG,IAAI;IACzB,OAAO,YAAA;MACH,UAAU,CAAC,OAAO,GAAG,KAAK;IAC9B,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;EACN,IAAM,YAAY,GAAG,WAAW,CAC5B,UAAA,IAAI,EAAA;IACA,IAAI,UAAU,CAAC,OAAO,EAAE;MACpB,OAAO,QAAQ,CAAC,IAAI,CAAC;IACxB;EACL,CAAC,EACD,CAAC,UAAU,EAAE,QAAQ,CAAC,CACzB;EAED,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC;AAChC;AAEA,OAAM,SAAU,WAAW,CAAC,KAAK,EAAA;EAC7B,IAAM,GAAG,GAAG,MAAM,EAAE;EACpB,SAAS,CAAC,YAAA;IACN,GAAG,CAAC,OAAO,GAAG,KAAK;EACvB,CAAC,CAAC;EACF,OAAO,GAAG,CAAC,OAAO;AACtB;AAEA,OAAM,SAAU,oBAAoB,CAAC,QAAQ,EAAE,MAAM,EAAA;EACjD,IAAM,UAAU,GAAG,MAAM,EAAE;EAC3B,SAAS,CAAC,YAAA;IACN,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,MAAM,CAAC,EAAE;MAClC,UAAU,CAAC,OAAO,GAAG,QAAQ,EAAE;IAClC;IACD,OAAO,UAAU,CAAC,OAAO;EAC7B,CAAC,CAAC;EACF,IAAM,cAAc,GAAG,WAAW,CAAC,MAAM,CAAC;AAC9C;AAEA;;;;;AAKG;AACH,OAAM,SAAU,UAAU,CAAC,EAAM,EAAE,GAAQ,EAAA;EAAhB,IAAA,EAAA,KAAA,KAAA,CAAA,EAAA;IAAA,EAAA,GAAA,CAAM;EAAA;EAAE,IAAA,GAAA,KAAA,KAAA,CAAA,EAAA;IAAA,GAAA,GAAA,EAAQ;EAAA;EACjC,IAAA,EAAA,GAAoB,eAAe,CAAC,KAAK,CAAC;IAAzC,KAAK,GAAA,EAAA,CAAA,CAAA,CAAA;IAAE,QAAQ,GAAA,EAAA,CAAA,CAAA,CAA0B;EAEhD,SAAS,CAAC,YAAA;IACN,QAAQ,CAAC,KAAK,CAAC;IACf,IAAI,KAAK,GAAG,UAAU,CAAC,YAAA;MACnB,QAAQ,CAAC,IAAI,CAAC;IAClB,CAAC,EAAE,EAAE,CAAC;IAEN,OAAO,YAAA;MACH,YAAY,CAAC,KAAK,CAAC;IACvB,CAAC;EACL,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAC;EAEvB,OAAO,KAAK;AAChB;AAEA,OAAM,SAAU,YAAY,GAAA;EACxB,IAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC;EAC9B,SAAS,CAAC,YAAA;IACN,SAAS,CAAC,OAAO,GAAG,IAAI;IACxB,OAAO,YAAA;MACH,SAAS,CAAC,OAAO,GAAG,KAAK;IAC7B,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;EACN,OAAO,SAAS;AACpB","sourceRoot":"","sourcesContent":["import { useState, useRef, useEffect, useCallback } from 'react';\nimport isEqual from 'lodash/isEqual';\n// thanks Kent C Dodds for the following helpers\nexport function useSafeSetState(initialState) {\n    var _a = useState(initialState), state = _a[0], setState = _a[1];\n    var mountedRef = useRef(false);\n    useEffect(function () {\n        mountedRef.current = true;\n        return function () {\n            mountedRef.current = false;\n        };\n    }, []);\n    var safeSetState = useCallback(function (args) {\n        if (mountedRef.current) {\n            return setState(args);\n        }\n    }, [mountedRef, setState]);\n    return [state, safeSetState];\n}\nexport function usePrevious(value) {\n    var ref = useRef();\n    useEffect(function () {\n        ref.current = value;\n    });\n    return ref.current;\n}\nexport function useDeepCompareEffect(callback, inputs) {\n    var cleanupRef = useRef();\n    useEffect(function () {\n        if (!isEqual(previousInputs, inputs)) {\n            cleanupRef.current = callback();\n        }\n        return cleanupRef.current;\n    });\n    var previousInputs = usePrevious(inputs);\n}\n/**\n * A hook that returns true once a delay has expired.\n * @param ms The delay in milliseconds\n * @param key A key that can be used to reset the timer\n * @returns true if the delay has expired, false otherwise\n */\nexport function useTimeout(ms, key) {\n    if (ms === void 0) { ms = 0; }\n    if (key === void 0) { key = ''; }\n    var _a = useSafeSetState(false), ready = _a[0], setReady = _a[1];\n    useEffect(function () {\n        setReady(false);\n        var timer = setTimeout(function () {\n            setReady(true);\n        }, ms);\n        return function () {\n            clearTimeout(timer);\n        };\n    }, [key, ms, setReady]);\n    return ready;\n}\nexport function useIsMounted() {\n    var isMounted = useRef(true);\n    useEffect(function () {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n//# sourceMappingURL=hooks.js.map"]},"metadata":{},"sourceType":"module"}