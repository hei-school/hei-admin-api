{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nimport { browserOrNode, ConsoleLogger as Logger, BackgroundProcessManager } from '@aws-amplify/core';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG } from '@aws-amplify/pubsub';\nimport Observable from 'zen-observable-ts';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType } from '../types';\nimport { exhaustiveCheck, getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport { createMutationInstanceFromModelOperation, getIdentifierValue, predicateToGraphQLCondition } from './utils';\nvar isNode = browserOrNode().isNode;\nvar logger = new Logger('DataStore');\nvar ownSymbol = Symbol('sync');\nexport var ControlMessage;\n(function (ControlMessage) {\n  ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n  ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n  ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n  ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n  ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n})(ControlMessage || (ControlMessage = {}));\nvar SyncEngine = /** @class */function () {\n  function SyncEngine(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, conflictHandler, errorHandler, syncPredicates, amplifyConfig, authModeStrategy, amplifyContext, connectivityMonitor) {\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.modelClasses = modelClasses;\n    this.userModelClasses = userModelClasses;\n    this.storage = storage;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.amplifyContext = amplifyContext;\n    this.connectivityMonitor = connectivityMonitor;\n    this.online = false;\n    this.modelSyncedStatus = new WeakMap();\n    this.runningProcesses = new BackgroundProcessManager();\n    var MutationEvent = this.modelClasses['MutationEvent'];\n    this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n    this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n    this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, errorHandler, conflictHandler, this.amplifyContext);\n    this.datastoreConnectivity = this.connectivityMonitor || new DataStoreConnectivity();\n  }\n  SyncEngine.prototype.getModelSyncedStatus = function (modelConstructor) {\n    return this.modelSyncedStatus.get(modelConstructor);\n  };\n  SyncEngine.prototype.start = function (params) {\n    var _this = this;\n    return new Observable(function (observer) {\n      logger.log('starting sync engine...');\n      var subscriptions = [];\n      _this.runningProcesses.add(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var err_1, startPromise, hasMutationsInOutbox;\n          var _this = this;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, this.setupModels(params)];\n              case 1:\n                _a.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                err_1 = _a.sent();\n                observer.error(err_1);\n                return [2 /*return*/];\n              case 3:\n                startPromise = new Promise(function (doneStarting, failedStarting) {\n                  _this.datastoreConnectivity.status().subscribe(function (_a) {\n                    var online = _a.online;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var _this = this;\n                      return __generator(this, function (_b) {\n                        return [2 /*return*/, this.runningProcesses.isOpen && this.runningProcesses.add(function (onTerminate) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var ctlSubsObservable_1, dataSubsObservable, err_2, error_1;\n                            var _a;\n                            var _this = this;\n                            return __generator(this, function (_b) {\n                              switch (_b.label) {\n                                case 0:\n                                  if (!(online && !this.online)) return [3 /*break*/, 10];\n                                  this.online = online;\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                    data: {\n                                      active: this.online\n                                    }\n                                  });\n                                  dataSubsObservable = void 0;\n                                  if (!isNode) return [3 /*break*/, 1];\n                                  logger.warn('Realtime disabled when in a server-side environment');\n                                  return [3 /*break*/, 6];\n                                case 1:\n                                  //#region GraphQL Subscriptions\n                                  _a = __read(this.subscriptionsProcessor.start(), 2),\n                                  // const ctlObservable: Observable<CONTROL_MSG>\n                                  ctlSubsObservable_1 = _a[0],\n                                  // const dataObservable: Observable<[TransformerMutationType, SchemaModel, Readonly<{\n                                  // id: string;\n                                  // } & Record<string, any>>]>\n                                  dataSubsObservable = _a[1];\n                                  _b.label = 2;\n                                case 2:\n                                  _b.trys.push([2, 4,, 5]);\n                                  return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                    onTerminate.then(reject);\n                                    var ctlSubsSubscription = ctlSubsObservable_1.subscribe({\n                                      next: function (msg) {\n                                        if (msg === CONTROL_MSG.CONNECTED) {\n                                          resolve();\n                                        }\n                                      },\n                                      error: function (err) {\n                                        reject(err);\n                                        var handleDisconnect = _this.disconnectionHandler();\n                                        handleDisconnect(err);\n                                      }\n                                    });\n                                    subscriptions.push(ctlSubsSubscription);\n                                  })];\n                                case 3:\n                                  _b.sent();\n                                  return [3 /*break*/, 5];\n                                case 4:\n                                  err_2 = _b.sent();\n                                  observer.error(err_2);\n                                  failedStarting();\n                                  return [2 /*return*/];\n                                case 5:\n                                  logger.log('Realtime ready');\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\n                                  });\n                                  _b.label = 6;\n                                case 6:\n                                  _b.trys.push([6, 8,, 9]);\n                                  return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                    var syncQuerySubscription = _this.syncQueriesObservable().subscribe({\n                                      next: function (message) {\n                                        var type = message.type;\n                                        if (type === ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                                          resolve();\n                                        }\n                                        observer.next(message);\n                                      },\n                                      complete: function () {\n                                        resolve();\n                                      },\n                                      error: function (error) {\n                                        reject(error);\n                                      }\n                                    });\n                                    if (syncQuerySubscription) {\n                                      subscriptions.push(syncQuerySubscription);\n                                    }\n                                  })];\n                                case 7:\n                                  _b.sent();\n                                  return [3 /*break*/, 9];\n                                case 8:\n                                  error_1 = _b.sent();\n                                  observer.error(error_1);\n                                  failedStarting();\n                                  return [2 /*return*/];\n                                case 9:\n                                  //#endregion\n                                  //#region process mutations (outbox)\n                                  subscriptions.push(this.mutationsProcessor.start().subscribe(function (_a) {\n                                    var modelDefinition = _a.modelDefinition,\n                                      item = _a.model,\n                                      hasMore = _a.hasMore;\n                                    return _this.runningProcesses.add(function () {\n                                      return __awaiter(_this, void 0, void 0, function () {\n                                        var modelConstructor, model;\n                                        var _this = this;\n                                        return __generator(this, function (_a) {\n                                          switch (_a.label) {\n                                            case 0:\n                                              modelConstructor = this.userModelClasses[modelDefinition.name];\n                                              model = this.modelInstanceCreator(modelConstructor, item);\n                                              return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                                return _this.modelMerger.merge(storage, model, modelDefinition);\n                                              })];\n                                            case 1:\n                                              _a.sent();\n                                              observer.next({\n                                                type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                                                data: {\n                                                  model: modelConstructor,\n                                                  element: model\n                                                }\n                                              });\n                                              observer.next({\n                                                type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                                data: {\n                                                  isEmpty: !hasMore\n                                                }\n                                              });\n                                              return [2 /*return*/];\n                                          }\n                                        });\n                                      });\n                                    }, 'mutation processor event');\n                                  }));\n                                  //#endregion\n                                  //#region Merge subscriptions buffer\n                                  // TODO: extract to function\n                                  if (!isNode) {\n                                    subscriptions.push(dataSubsObservable.subscribe(function (_a) {\n                                      var _b = __read(_a, 3),\n                                        _transformerMutationType = _b[0],\n                                        modelDefinition = _b[1],\n                                        item = _b[2];\n                                      return _this.runningProcesses.add(function () {\n                                        return __awaiter(_this, void 0, void 0, function () {\n                                          var modelConstructor, model;\n                                          var _this = this;\n                                          return __generator(this, function (_a) {\n                                            switch (_a.label) {\n                                              case 0:\n                                                modelConstructor = this.userModelClasses[modelDefinition.name];\n                                                model = this.modelInstanceCreator(modelConstructor, item);\n                                                return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                                  return _this.modelMerger.merge(storage, model, modelDefinition);\n                                                })];\n                                              case 1:\n                                                _a.sent();\n                                                return [2 /*return*/];\n                                            }\n                                          });\n                                        });\n                                      }, 'subscription dataSubsObservable event');\n                                    }));\n                                  }\n                                  return [3 /*break*/, 11];\n                                case 10:\n                                  if (!online) {\n                                    this.online = online;\n                                    observer.next({\n                                      type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                      data: {\n                                        active: this.online\n                                      }\n                                    });\n                                    subscriptions.forEach(function (sub) {\n                                      return sub.unsubscribe();\n                                    });\n                                    subscriptions = [];\n                                  }\n                                  _b.label = 11;\n                                case 11:\n                                  doneStarting();\n                                  return [2 /*return*/];\n                              }\n                            });\n                          });\n                        }, 'datastore connectivity event')];\n                      });\n                    });\n                  });\n                });\n                this.storage.observe(null, null, ownSymbol).filter(function (_a) {\n                  var model = _a.model;\n                  var modelDefinition = _this.getModelDefinition(model);\n                  return modelDefinition.syncable === true;\n                }).subscribe({\n                  next: function (_a) {\n                    var opType = _a.opType,\n                      model = _a.model,\n                      element = _a.element,\n                      condition = _a.condition;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var _this = this;\n                      return __generator(this, function (_b) {\n                        return [2 /*return*/, this.runningProcesses.add(function () {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var namespace, MutationEventConstructor, modelDefinition, graphQLCondition, mutationEvent;\n                            return __generator(this, function (_a) {\n                              switch (_a.label) {\n                                case 0:\n                                  namespace = this.schema.namespaces[this.namespaceResolver(model)];\n                                  MutationEventConstructor = this.modelClasses['MutationEvent'];\n                                  modelDefinition = this.getModelDefinition(model);\n                                  graphQLCondition = predicateToGraphQLCondition(condition, modelDefinition);\n                                  mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n                                  return [4 /*yield*/, this.outbox.enqueue(this.storage, mutationEvent)];\n                                case 1:\n                                  _a.sent();\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n                                    data: {\n                                      model: model,\n                                      element: element\n                                    }\n                                  });\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                    data: {\n                                      isEmpty: false\n                                    }\n                                  });\n                                  return [4 /*yield*/, startPromise];\n                                case 2:\n                                  _a.sent();\n                                  if (this.online) {\n                                    this.mutationsProcessor.resume();\n                                  }\n                                  return [2 /*return*/];\n                              }\n                            });\n                          });\n                        }, 'storage event')];\n                      });\n                    });\n                  }\n                });\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED\n                });\n                return [4 /*yield*/, this.outbox.peek(this.storage)];\n              case 4:\n                hasMutationsInOutbox = _a.sent() === undefined;\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                  data: {\n                    isEmpty: hasMutationsInOutbox\n                  }\n                });\n                return [4 /*yield*/, startPromise];\n              case 5:\n                _a.sent();\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_READY\n                });\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, 'sync start');\n    });\n  };\n  SyncEngine.prototype.getModelsMetadataWithNextFullSync = function (currentTimeStamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelLastSync, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Map.bind;\n            return [4 /*yield*/, this.runningProcesses.add(function () {\n              return _this.getModelsMetadata();\n            }, 'sync/index getModelsMetadataWithNextFullSync')];\n          case 1:\n            modelLastSync = new (_a.apply(Map, [void 0, _b.sent().map(function (_a) {\n              var namespace = _a.namespace,\n                model = _a.model,\n                lastSync = _a.lastSync,\n                lastFullSync = _a.lastFullSync,\n                fullSyncInterval = _a.fullSyncInterval,\n                lastSyncPredicate = _a.lastSyncPredicate;\n              var nextFullSync = lastFullSync + fullSyncInterval;\n              var syncFrom = !lastFullSync || nextFullSync < currentTimeStamp ? 0 // perform full sync if expired\n              : lastSync; // perform delta sync\n              return [_this.schema.namespaces[namespace].models[model], [namespace, syncFrom]];\n            })]))();\n            return [2 /*return*/, modelLastSync];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.syncQueriesObservable = function () {\n    var _this = this;\n    if (!this.online) {\n      return Observable.of();\n    }\n    return new Observable(function (observer) {\n      var syncQueriesSubscription;\n      _this.runningProcesses.isOpen && _this.runningProcesses.add(function (onTerminate) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var terminated, _loop_1, this_1;\n          var _this = this;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                terminated = false;\n                _loop_1 = function () {\n                  var count, modelLastSync, paginatingModels, newestFullSyncStartedAt, theInterval, start, duration, newestStartedAt, msNextFullSync;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        count = new WeakMap();\n                        return [4 /*yield*/, this_1.getModelsMetadataWithNextFullSync(Date.now())];\n                      case 1:\n                        modelLastSync = _a.sent();\n                        paginatingModels = new Set(modelLastSync.keys());\n                        return [4 /*yield*/, new Promise(function (resolve, reject) {\n                          if (!_this.runningProcesses.isOpen) resolve();\n                          onTerminate.then(function () {\n                            return resolve();\n                          });\n                          syncQueriesSubscription = _this.syncQueriesProcessor.start(modelLastSync).subscribe({\n                            next: function (_a) {\n                              var namespace = _a.namespace,\n                                modelDefinition = _a.modelDefinition,\n                                items = _a.items,\n                                done = _a.done,\n                                startedAt = _a.startedAt,\n                                isFullSync = _a.isFullSync;\n                              return __awaiter(_this, void 0, void 0, function () {\n                                var modelConstructor, modelName, modelMetadata_1, lastFullSync, fullSyncInterval, counts;\n                                var _this = this;\n                                return __generator(this, function (_b) {\n                                  switch (_b.label) {\n                                    case 0:\n                                      modelConstructor = this.userModelClasses[modelDefinition.name];\n                                      if (!count.has(modelConstructor)) {\n                                        count.set(modelConstructor, {\n                                          new: 0,\n                                          updated: 0,\n                                          deleted: 0\n                                        });\n                                        start = getNow();\n                                        newestStartedAt = newestStartedAt === undefined ? startedAt : Math.max(newestStartedAt, startedAt);\n                                      }\n                                      /**\n                                       * If there are mutations in the outbox for a given id, those need to be\n                                       * merged individually. Otherwise, we can merge them in batches.\n                                       */\n                                      return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                        return __awaiter(_this, void 0, void 0, function () {\n                                          var idsInOutbox, oneByOne, page, opTypeCount, oneByOne_1, oneByOne_1_1, item, opType, e_1_1, _a, _b, _c, counts;\n                                          var e_1, _d;\n                                          return __generator(this, function (_e) {\n                                            switch (_e.label) {\n                                              case 0:\n                                                return [4 /*yield*/, this.outbox.getModelIds(storage)];\n                                              case 1:\n                                                idsInOutbox = _e.sent();\n                                                oneByOne = [];\n                                                page = items.filter(function (item) {\n                                                  var itemId = getIdentifierValue(modelDefinition, item);\n                                                  if (!idsInOutbox.has(itemId)) {\n                                                    return true;\n                                                  }\n                                                  oneByOne.push(item);\n                                                  return false;\n                                                });\n                                                opTypeCount = [];\n                                                _e.label = 2;\n                                              case 2:\n                                                _e.trys.push([2, 7, 8, 9]);\n                                                oneByOne_1 = __values(oneByOne), oneByOne_1_1 = oneByOne_1.next();\n                                                _e.label = 3;\n                                              case 3:\n                                                if (!!oneByOne_1_1.done) return [3 /*break*/, 6];\n                                                item = oneByOne_1_1.value;\n                                                return [4 /*yield*/, this.modelMerger.merge(storage, item, modelDefinition)];\n                                              case 4:\n                                                opType = _e.sent();\n                                                if (opType !== undefined) {\n                                                  opTypeCount.push([item, opType]);\n                                                }\n                                                _e.label = 5;\n                                              case 5:\n                                                oneByOne_1_1 = oneByOne_1.next();\n                                                return [3 /*break*/, 3];\n                                              case 6:\n                                                return [3 /*break*/, 9];\n                                              case 7:\n                                                e_1_1 = _e.sent();\n                                                e_1 = {\n                                                  error: e_1_1\n                                                };\n                                                return [3 /*break*/, 9];\n                                              case 8:\n                                                try {\n                                                  if (oneByOne_1_1 && !oneByOne_1_1.done && (_d = oneByOne_1.return)) _d.call(oneByOne_1);\n                                                } finally {\n                                                  if (e_1) throw e_1.error;\n                                                }\n                                                return [7 /*endfinally*/];\n                                              case 9:\n                                                _b = (_a = opTypeCount.push).apply;\n                                                _c = [opTypeCount];\n                                                return [4 /*yield*/, this.modelMerger.mergePage(storage, modelConstructor, page, modelDefinition)];\n                                              case 10:\n                                                _b.apply(_a, _c.concat([__spread.apply(void 0, [_e.sent()])]));\n                                                counts = count.get(modelConstructor);\n                                                opTypeCount.forEach(function (_a) {\n                                                  var _b = __read(_a, 2),\n                                                    opType = _b[1];\n                                                  switch (opType) {\n                                                    case OpType.INSERT:\n                                                      counts.new++;\n                                                      break;\n                                                    case OpType.UPDATE:\n                                                      counts.updated++;\n                                                      break;\n                                                    case OpType.DELETE:\n                                                      counts.deleted++;\n                                                      break;\n                                                    default:\n                                                      exhaustiveCheck(opType);\n                                                  }\n                                                });\n                                                return [2 /*return*/];\n                                            }\n                                          });\n                                        });\n                                      })];\n\n                                    case 1:\n                                      /**\n                                       * If there are mutations in the outbox for a given id, those need to be\n                                       * merged individually. Otherwise, we can merge them in batches.\n                                       */\n                                      _b.sent();\n                                      if (!done) return [3 /*break*/, 4];\n                                      modelName = modelDefinition.name;\n                                      return [4 /*yield*/, this.getModelMetadata(namespace, modelName)];\n                                    case 2:\n                                      modelMetadata_1 = _b.sent();\n                                      lastFullSync = modelMetadata_1.lastFullSync, fullSyncInterval = modelMetadata_1.fullSyncInterval;\n                                      theInterval = fullSyncInterval;\n                                      newestFullSyncStartedAt = newestFullSyncStartedAt === undefined ? lastFullSync : Math.max(newestFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                                      modelMetadata_1 = this.modelClasses.ModelMetadata.copyOf(modelMetadata_1, function (draft) {\n                                        draft.lastSync = startedAt;\n                                        draft.lastFullSync = isFullSync ? startedAt : modelMetadata_1.lastFullSync;\n                                      });\n                                      return [4 /*yield*/, this.storage.save(modelMetadata_1, undefined, ownSymbol)];\n                                    case 3:\n                                      _b.sent();\n                                      counts = count.get(modelConstructor);\n                                      this.modelSyncedStatus.set(modelConstructor, true);\n                                      observer.next({\n                                        type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                                        data: {\n                                          model: modelConstructor,\n                                          isFullSync: isFullSync,\n                                          isDeltaSync: !isFullSync,\n                                          counts: counts\n                                        }\n                                      });\n                                      paginatingModels.delete(modelDefinition);\n                                      if (paginatingModels.size === 0) {\n                                        duration = getNow() - start;\n                                        resolve();\n                                        observer.next({\n                                          type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n                                        });\n                                        syncQueriesSubscription.unsubscribe();\n                                      }\n                                      _b.label = 4;\n                                    case 4:\n                                      return [2 /*return*/];\n                                  }\n                                });\n                              });\n                            },\n\n                            error: function (error) {\n                              observer.error(error);\n                            }\n                          });\n                          observer.next({\n                            type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n                            data: {\n                              models: Array.from(paginatingModels).map(function (_a) {\n                                var name = _a.name;\n                                return name;\n                              })\n                            }\n                          });\n                        })];\n                      case 2:\n                        _a.sent();\n                        msNextFullSync = newestFullSyncStartedAt + theInterval - (newestStartedAt + duration);\n                        logger.debug(\"Next fullSync in \" + msNextFullSync / 1000 + \" seconds. (\" + new Date(Date.now() + msNextFullSync) + \")\");\n                        // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                        // a lot of thought into what that contract looks like to\n                        //  support possible use-cases:\n                        //\n                        //  1. non-cancelable\n                        //  2. cancelable, unsleep on exit()\n                        //  3. cancelable, throw Error on exit()\n                        //  4. cancelable, callback first on exit()?\n                        //  5. ... etc. ? ...\n                        //\n                        // TLDR; this is a lot of complexity here for a sleep(),\n                        // but, it's not clear to me yet how to support an\n                        // extensible, centralized cancelable `sleep()` elegantly.\n                        return [4 /*yield*/, this_1.runningProcesses.add(function (onTerminate) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var sleepTimer, unsleep, sleep;\n                            return __generator(this, function (_a) {\n                              sleep = new Promise(function (_unsleep) {\n                                unsleep = _unsleep;\n                                sleepTimer = setTimeout(unsleep, msNextFullSync);\n                              });\n                              onTerminate.then(function () {\n                                terminated = true;\n                                unsleep();\n                              });\n                              return [2 /*return*/, sleep];\n                            });\n                          });\n                        }, 'syncQueriesObservable sleep')];\n                      case 3:\n                        // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                        // a lot of thought into what that contract looks like to\n                        //  support possible use-cases:\n                        //\n                        //  1. non-cancelable\n                        //  2. cancelable, unsleep on exit()\n                        //  3. cancelable, throw Error on exit()\n                        //  4. cancelable, callback first on exit()?\n                        //  5. ... etc. ? ...\n                        //\n                        // TLDR; this is a lot of complexity here for a sleep(),\n                        // but, it's not clear to me yet how to support an\n                        // extensible, centralized cancelable `sleep()` elegantly.\n                        _a.sent();\n                        return [2 /*return*/];\n                    }\n                  });\n                };\n\n                this_1 = this;\n                _a.label = 1;\n              case 1:\n                if (!(!observer.closed && !terminated)) return [3 /*break*/, 3];\n                return [5 /*yield**/, _loop_1()];\n              case 2:\n                _a.sent();\n                return [3 /*break*/, 1];\n              case 3:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, 'syncQueriesObservable main');\n    });\n  };\n  SyncEngine.prototype.disconnectionHandler = function () {\n    var _this = this;\n    return function (msg) {\n      // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n      if (PUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg || PUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg) {\n        _this.datastoreConnectivity.socketDisconnected();\n      }\n    };\n  };\n  SyncEngine.prototype.unsubscribeConnectivity = function () {\n    this.datastoreConnectivity.unsubscribe();\n  };\n  /**\n   * Stops all subscription activities and resolves when all activies report\n   * that they're disconnected, done retrying, etc..\n   */\n  SyncEngine.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug('stopping sync engine');\n            /**\n             * Gracefully disconnecting subscribers first just prevents *more* work\n             * from entering the pipelines.\n             */\n            this.unsubscribeConnectivity();\n            /**\n             * aggressively shut down any lingering background processes.\n             * some of this might be semi-redundant with unsubscribing. however,\n             * unsubscribing doesn't allow us to wait for settling.\n             * (Whereas `stop()` does.)\n             */\n            return [4 /*yield*/, this.mutationsProcessor.stop()];\n          case 1:\n            /**\n             * aggressively shut down any lingering background processes.\n             * some of this might be semi-redundant with unsubscribing. however,\n             * unsubscribing doesn't allow us to wait for settling.\n             * (Whereas `stop()` does.)\n             */\n            _a.sent();\n            return [4 /*yield*/, this.subscriptionsProcessor.stop()];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, this.datastoreConnectivity.stop()];\n          case 3:\n            _a.sent();\n            return [4 /*yield*/, this.syncQueriesProcessor.stop()];\n          case 4:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 5:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 6:\n            _a.sent();\n            logger.debug('sync engine stopped and ready to restart');\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  SyncEngine.prototype.setupModels = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fullSyncInterval, ModelMetadataConstructor, models, savedModel, promises, result, _a, _b, modelMetadata, modelName, e_2_1;\n      var e_2, _c;\n      var _this = this;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            fullSyncInterval = params.fullSyncInterval;\n            ModelMetadataConstructor = this.modelClasses.ModelMetadata;\n            models = [];\n            Object.values(this.schema.namespaces).forEach(function (namespace) {\n              Object.values(namespace.models).filter(function (_a) {\n                var syncable = _a.syncable;\n                return syncable;\n              }).forEach(function (model) {\n                models.push([namespace.name, model]);\n                if (namespace.name === USER) {\n                  var modelConstructor = _this.userModelClasses[model.name];\n                  _this.modelSyncedStatus.set(modelConstructor, false);\n                }\n              });\n            });\n            promises = models.map(function (_a) {\n              var _b = __read(_a, 2),\n                namespace = _b[0],\n                model = _b[1];\n              return __awaiter(_this, void 0, void 0, function () {\n                var modelMetadata, syncPredicate, lastSyncPredicate, prevSyncPredicate, syncPredicateUpdated_1;\n                var _c, _d, _e, _f;\n                return __generator(this, function (_g) {\n                  switch (_g.label) {\n                    case 0:\n                      return [4 /*yield*/, this.getModelMetadata(namespace, model.name)];\n                    case 1:\n                      modelMetadata = _g.sent();\n                      syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n                      lastSyncPredicate = syncPredicate ? JSON.stringify(syncPredicate) : null;\n                      if (!(modelMetadata === undefined)) return [3 /*break*/, 3];\n                      return [4 /*yield*/, this.storage.save(this.modelInstanceCreator(ModelMetadataConstructor, {\n                        model: model.name,\n                        namespace: namespace,\n                        lastSync: null,\n                        fullSyncInterval: fullSyncInterval,\n                        lastFullSync: null,\n                        lastSyncPredicate: lastSyncPredicate\n                      }), undefined, ownSymbol)];\n                    case 2:\n                      _c = __read.apply(void 0, [_g.sent(), 1]), _d = __read(_c[0], 1), savedModel = _d[0];\n                      return [3 /*break*/, 5];\n                    case 3:\n                      prevSyncPredicate = modelMetadata.lastSyncPredicate ? modelMetadata.lastSyncPredicate : null;\n                      syncPredicateUpdated_1 = prevSyncPredicate !== lastSyncPredicate;\n                      return [4 /*yield*/, this.storage.save(ModelMetadataConstructor.copyOf(modelMetadata, function (draft) {\n                        draft.fullSyncInterval = fullSyncInterval;\n                        // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n                        // ensures that the local store contains all the data specified by the syncExpression\n                        if (syncPredicateUpdated_1) {\n                          draft.lastSync = null;\n                          draft.lastFullSync = null;\n                          draft.lastSyncPredicate = lastSyncPredicate;\n                        }\n                      }))];\n                    case 4:\n                      _e = __read.apply(void 0, [_g.sent(), 1]), _f = __read(_e[0], 1), savedModel = _f[0];\n                      _g.label = 5;\n                    case 5:\n                      return [2 /*return*/, savedModel];\n                  }\n                });\n              });\n            });\n            result = {};\n            _d.label = 1;\n          case 1:\n            _d.trys.push([1, 6, 7, 8]);\n            return [4 /*yield*/, Promise.all(promises)];\n          case 2:\n            _a = __values.apply(void 0, [_d.sent()]), _b = _a.next();\n            _d.label = 3;\n          case 3:\n            if (!!_b.done) return [3 /*break*/, 5];\n            modelMetadata = _b.value;\n            modelName = modelMetadata.model;\n            result[modelName] = modelMetadata;\n            _d.label = 4;\n          case 4:\n            _b = _a.next();\n            return [3 /*break*/, 3];\n          case 5:\n            return [3 /*break*/, 8];\n          case 6:\n            e_2_1 = _d.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 8];\n          case 7:\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n            return [7 /*endfinally*/];\n          case 8:\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelsMetadata = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, modelsMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            return [4 /*yield*/, this.storage.query(ModelMetadata)];\n          case 1:\n            modelsMetadata = _a.sent();\n            return [2 /*return*/, modelsMetadata];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelMetadata = function (namespace, model) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, predicate, _a, modelMetadata;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            predicate = ModelPredicateCreator.createFromExisting(this.schema.namespaces[SYNC].models[ModelMetadata.name], function (c) {\n              return c.namespace('eq', namespace).model('eq', model);\n            });\n            return [4 /*yield*/, this.storage.query(ModelMetadata, predicate, {\n              page: 0,\n              limit: 1\n            })];\n          case 1:\n            _a = __read.apply(void 0, [_b.sent(), 1]), modelMetadata = _a[0];\n            return [2 /*return*/, modelMetadata];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelDefinition = function (modelConstructor) {\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n    return modelDefinition;\n  };\n  SyncEngine.getNamespace = function () {\n    var namespace = {\n      name: SYNC,\n      relationships: {},\n      enums: {\n        OperationType: {\n          name: 'OperationType',\n          values: ['CREATE', 'UPDATE', 'DELETE']\n        }\n      },\n      nonModels: {},\n      models: {\n        MutationEvent: {\n          name: 'MutationEvent',\n          pluralName: 'MutationEvents',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            data: {\n              name: 'data',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            modelId: {\n              name: 'modelId',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            operation: {\n              name: 'operation',\n              type: {\n                enum: 'Operationtype'\n              },\n              isArray: false,\n              isRequired: true\n            },\n            condition: {\n              name: 'condition',\n              type: 'String',\n              isArray: false,\n              isRequired: true\n            }\n          }\n        },\n        ModelMetadata: {\n          name: 'ModelMetadata',\n          pluralName: 'ModelsMetadata',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            namespace: {\n              name: 'namespace',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            lastSync: {\n              name: 'lastSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            lastFullSync: {\n              name: 'lastFullSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            fullSyncInterval: {\n              name: 'fullSyncInterval',\n              type: 'Int',\n              isRequired: true,\n              isArray: false\n            },\n            lastSyncPredicate: {\n              name: 'lastSyncPredicate',\n              type: 'String',\n              isRequired: false,\n              isArray: false\n            }\n          }\n        }\n      }\n    };\n    return namespace;\n  };\n  return SyncEngine;\n}();\nexport { SyncEngine };","map":{"version":3,"sources":["../../src/sync/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { browserOrNode, ConsoleLogger as Logger, BackgroundProcessManager, } from '@aws-amplify/core';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG } from '@aws-amplify/pubsub';\nimport Observable from 'zen-observable-ts';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType, } from '../types';\nimport { exhaustiveCheck, getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport { createMutationInstanceFromModelOperation, getIdentifierValue, predicateToGraphQLCondition, } from './utils';\nvar isNode = browserOrNode().isNode;\nvar logger = new Logger('DataStore');\nvar ownSymbol = Symbol('sync');\nexport var ControlMessage;\n(function (ControlMessage) {\n    ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n    ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n    ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n    ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n    ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n    ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n    ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n})(ControlMessage || (ControlMessage = {}));\nvar SyncEngine = /** @class */ (function () {\n    function SyncEngine(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, conflictHandler, errorHandler, syncPredicates, amplifyConfig, authModeStrategy, amplifyContext, connectivityMonitor) {\n        if (amplifyConfig === void 0) { amplifyConfig = {}; }\n        this.schema = schema;\n        this.namespaceResolver = namespaceResolver;\n        this.modelClasses = modelClasses;\n        this.userModelClasses = userModelClasses;\n        this.storage = storage;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.syncPredicates = syncPredicates;\n        this.amplifyConfig = amplifyConfig;\n        this.authModeStrategy = authModeStrategy;\n        this.amplifyContext = amplifyContext;\n        this.connectivityMonitor = connectivityMonitor;\n        this.online = false;\n        this.modelSyncedStatus = new WeakMap();\n        this.runningProcesses = new BackgroundProcessManager();\n        var MutationEvent = this.modelClasses['MutationEvent'];\n        this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n        this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n        this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n        this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n        this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, errorHandler, conflictHandler, this.amplifyContext);\n        this.datastoreConnectivity =\n            this.connectivityMonitor || new DataStoreConnectivity();\n    }\n    SyncEngine.prototype.getModelSyncedStatus = function (modelConstructor) {\n        return this.modelSyncedStatus.get(modelConstructor);\n    };\n    SyncEngine.prototype.start = function (params) {\n        var _this = this;\n        return new Observable(function (observer) {\n            logger.log('starting sync engine...');\n            var subscriptions = [];\n            _this.runningProcesses.add(function () { return __awaiter(_this, void 0, void 0, function () {\n                var err_1, startPromise, hasMutationsInOutbox;\n                var _this = this;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            _a.trys.push([0, 2, , 3]);\n                            return [4 /*yield*/, this.setupModels(params)];\n                        case 1:\n                            _a.sent();\n                            return [3 /*break*/, 3];\n                        case 2:\n                            err_1 = _a.sent();\n                            observer.error(err_1);\n                            return [2 /*return*/];\n                        case 3:\n                            startPromise = new Promise(function (doneStarting, failedStarting) {\n                                _this.datastoreConnectivity.status().subscribe(function (_a) {\n                                    var online = _a.online;\n                                    return __awaiter(_this, void 0, void 0, function () {\n                                        var _this = this;\n                                        return __generator(this, function (_b) {\n                                            return [2 /*return*/, this.runningProcesses.isOpen &&\n                                                    this.runningProcesses.add(function (onTerminate) { return __awaiter(_this, void 0, void 0, function () {\n                                                        var ctlSubsObservable_1, dataSubsObservable, err_2, error_1;\n                                                        var _a;\n                                                        var _this = this;\n                                                        return __generator(this, function (_b) {\n                                                            switch (_b.label) {\n                                                                case 0:\n                                                                    if (!(online && !this.online)) return [3 /*break*/, 10];\n                                                                    this.online = online;\n                                                                    observer.next({\n                                                                        type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                                                        data: {\n                                                                            active: this.online,\n                                                                        },\n                                                                    });\n                                                                    dataSubsObservable = void 0;\n                                                                    if (!isNode) return [3 /*break*/, 1];\n                                                                    logger.warn('Realtime disabled when in a server-side environment');\n                                                                    return [3 /*break*/, 6];\n                                                                case 1:\n                                                                    //#region GraphQL Subscriptions\n                                                                    _a = __read(this.subscriptionsProcessor.start(), 2), \n                                                                    // const ctlObservable: Observable<CONTROL_MSG>\n                                                                    ctlSubsObservable_1 = _a[0], \n                                                                    // const dataObservable: Observable<[TransformerMutationType, SchemaModel, Readonly<{\n                                                                    // id: string;\n                                                                    // } & Record<string, any>>]>\n                                                                    dataSubsObservable = _a[1];\n                                                                    _b.label = 2;\n                                                                case 2:\n                                                                    _b.trys.push([2, 4, , 5]);\n                                                                    return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                                                            onTerminate.then(reject);\n                                                                            var ctlSubsSubscription = ctlSubsObservable_1.subscribe({\n                                                                                next: function (msg) {\n                                                                                    if (msg === CONTROL_MSG.CONNECTED) {\n                                                                                        resolve();\n                                                                                    }\n                                                                                },\n                                                                                error: function (err) {\n                                                                                    reject(err);\n                                                                                    var handleDisconnect = _this.disconnectionHandler();\n                                                                                    handleDisconnect(err);\n                                                                                },\n                                                                            });\n                                                                            subscriptions.push(ctlSubsSubscription);\n                                                                        })];\n                                                                case 3:\n                                                                    _b.sent();\n                                                                    return [3 /*break*/, 5];\n                                                                case 4:\n                                                                    err_2 = _b.sent();\n                                                                    observer.error(err_2);\n                                                                    failedStarting();\n                                                                    return [2 /*return*/];\n                                                                case 5:\n                                                                    logger.log('Realtime ready');\n                                                                    observer.next({\n                                                                        type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED,\n                                                                    });\n                                                                    _b.label = 6;\n                                                                case 6:\n                                                                    _b.trys.push([6, 8, , 9]);\n                                                                    return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                                                            var syncQuerySubscription = _this.syncQueriesObservable().subscribe({\n                                                                                next: function (message) {\n                                                                                    var type = message.type;\n                                                                                    if (type ===\n                                                                                        ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                                                                                        resolve();\n                                                                                    }\n                                                                                    observer.next(message);\n                                                                                },\n                                                                                complete: function () {\n                                                                                    resolve();\n                                                                                },\n                                                                                error: function (error) {\n                                                                                    reject(error);\n                                                                                },\n                                                                            });\n                                                                            if (syncQuerySubscription) {\n                                                                                subscriptions.push(syncQuerySubscription);\n                                                                            }\n                                                                        })];\n                                                                case 7:\n                                                                    _b.sent();\n                                                                    return [3 /*break*/, 9];\n                                                                case 8:\n                                                                    error_1 = _b.sent();\n                                                                    observer.error(error_1);\n                                                                    failedStarting();\n                                                                    return [2 /*return*/];\n                                                                case 9:\n                                                                    //#endregion\n                                                                    //#region process mutations (outbox)\n                                                                    subscriptions.push(this.mutationsProcessor\n                                                                        .start()\n                                                                        .subscribe(function (_a) {\n                                                                        var modelDefinition = _a.modelDefinition, item = _a.model, hasMore = _a.hasMore;\n                                                                        return _this.runningProcesses.add(function () { return __awaiter(_this, void 0, void 0, function () {\n                                                                            var modelConstructor, model;\n                                                                            var _this = this;\n                                                                            return __generator(this, function (_a) {\n                                                                                switch (_a.label) {\n                                                                                    case 0:\n                                                                                        modelConstructor = this.userModelClasses[modelDefinition.name];\n                                                                                        model = this.modelInstanceCreator(modelConstructor, item);\n                                                                                        return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                                                                                return _this.modelMerger.merge(storage, model, modelDefinition);\n                                                                                            })];\n                                                                                    case 1:\n                                                                                        _a.sent();\n                                                                                        observer.next({\n                                                                                            type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                                                                                            data: {\n                                                                                                model: modelConstructor,\n                                                                                                element: model,\n                                                                                            },\n                                                                                        });\n                                                                                        observer.next({\n                                                                                            type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                                                                            data: {\n                                                                                                isEmpty: !hasMore,\n                                                                                            },\n                                                                                        });\n                                                                                        return [2 /*return*/];\n                                                                                }\n                                                                            });\n                                                                        }); }, 'mutation processor event');\n                                                                    }));\n                                                                    //#endregion\n                                                                    //#region Merge subscriptions buffer\n                                                                    // TODO: extract to function\n                                                                    if (!isNode) {\n                                                                        subscriptions.push(dataSubsObservable.subscribe(function (_a) {\n                                                                            var _b = __read(_a, 3), _transformerMutationType = _b[0], modelDefinition = _b[1], item = _b[2];\n                                                                            return _this.runningProcesses.add(function () { return __awaiter(_this, void 0, void 0, function () {\n                                                                                var modelConstructor, model;\n                                                                                var _this = this;\n                                                                                return __generator(this, function (_a) {\n                                                                                    switch (_a.label) {\n                                                                                        case 0:\n                                                                                            modelConstructor = this.userModelClasses[modelDefinition.name];\n                                                                                            model = this.modelInstanceCreator(modelConstructor, item);\n                                                                                            return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                                                                                    return _this.modelMerger.merge(storage, model, modelDefinition);\n                                                                                                })];\n                                                                                        case 1:\n                                                                                            _a.sent();\n                                                                                            return [2 /*return*/];\n                                                                                    }\n                                                                                });\n                                                                            }); }, 'subscription dataSubsObservable event');\n                                                                        }));\n                                                                    }\n                                                                    return [3 /*break*/, 11];\n                                                                case 10:\n                                                                    if (!online) {\n                                                                        this.online = online;\n                                                                        observer.next({\n                                                                            type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                                                            data: {\n                                                                                active: this.online,\n                                                                            },\n                                                                        });\n                                                                        subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n                                                                        subscriptions = [];\n                                                                    }\n                                                                    _b.label = 11;\n                                                                case 11:\n                                                                    doneStarting();\n                                                                    return [2 /*return*/];\n                                                            }\n                                                        });\n                                                    }); }, 'datastore connectivity event')];\n                                        });\n                                    });\n                                });\n                            });\n                            this.storage\n                                .observe(null, null, ownSymbol)\n                                .filter(function (_a) {\n                                var model = _a.model;\n                                var modelDefinition = _this.getModelDefinition(model);\n                                return modelDefinition.syncable === true;\n                            })\n                                .subscribe({\n                                next: function (_a) {\n                                    var opType = _a.opType, model = _a.model, element = _a.element, condition = _a.condition;\n                                    return __awaiter(_this, void 0, void 0, function () {\n                                        var _this = this;\n                                        return __generator(this, function (_b) {\n                                            return [2 /*return*/, this.runningProcesses.add(function () { return __awaiter(_this, void 0, void 0, function () {\n                                                    var namespace, MutationEventConstructor, modelDefinition, graphQLCondition, mutationEvent;\n                                                    return __generator(this, function (_a) {\n                                                        switch (_a.label) {\n                                                            case 0:\n                                                                namespace = this.schema.namespaces[this.namespaceResolver(model)];\n                                                                MutationEventConstructor = this.modelClasses['MutationEvent'];\n                                                                modelDefinition = this.getModelDefinition(model);\n                                                                graphQLCondition = predicateToGraphQLCondition(condition, modelDefinition);\n                                                                mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n                                                                return [4 /*yield*/, this.outbox.enqueue(this.storage, mutationEvent)];\n                                                            case 1:\n                                                                _a.sent();\n                                                                observer.next({\n                                                                    type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n                                                                    data: {\n                                                                        model: model,\n                                                                        element: element,\n                                                                    },\n                                                                });\n                                                                observer.next({\n                                                                    type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                                                    data: {\n                                                                        isEmpty: false,\n                                                                    },\n                                                                });\n                                                                return [4 /*yield*/, startPromise];\n                                                            case 2:\n                                                                _a.sent();\n                                                                if (this.online) {\n                                                                    this.mutationsProcessor.resume();\n                                                                }\n                                                                return [2 /*return*/];\n                                                        }\n                                                    });\n                                                }); }, 'storage event')];\n                                        });\n                                    });\n                                },\n                            });\n                            observer.next({\n                                type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED,\n                            });\n                            return [4 /*yield*/, this.outbox.peek(this.storage)];\n                        case 4:\n                            hasMutationsInOutbox = (_a.sent()) === undefined;\n                            observer.next({\n                                type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                data: {\n                                    isEmpty: hasMutationsInOutbox,\n                                },\n                            });\n                            return [4 /*yield*/, startPromise];\n                        case 5:\n                            _a.sent();\n                            observer.next({\n                                type: ControlMessage.SYNC_ENGINE_READY,\n                            });\n                            return [2 /*return*/];\n                    }\n                });\n            }); }, 'sync start');\n        });\n    };\n    SyncEngine.prototype.getModelsMetadataWithNextFullSync = function (currentTimeStamp) {\n        return __awaiter(this, void 0, void 0, function () {\n            var modelLastSync, _a;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = Map.bind;\n                        return [4 /*yield*/, this.runningProcesses.add(function () { return _this.getModelsMetadata(); }, 'sync/index getModelsMetadataWithNextFullSync')];\n                    case 1:\n                        modelLastSync = new (_a.apply(Map, [void 0, (_b.sent()).map(function (_a) {\n                                var namespace = _a.namespace, model = _a.model, lastSync = _a.lastSync, lastFullSync = _a.lastFullSync, fullSyncInterval = _a.fullSyncInterval, lastSyncPredicate = _a.lastSyncPredicate;\n                                var nextFullSync = lastFullSync + fullSyncInterval;\n                                var syncFrom = !lastFullSync || nextFullSync < currentTimeStamp\n                                    ? 0 // perform full sync if expired\n                                    : lastSync; // perform delta sync\n                                return [\n                                    _this.schema.namespaces[namespace].models[model],\n                                    [namespace, syncFrom],\n                                ];\n                            })]))();\n                        return [2 /*return*/, modelLastSync];\n                }\n            });\n        });\n    };\n    SyncEngine.prototype.syncQueriesObservable = function () {\n        var _this = this;\n        if (!this.online) {\n            return Observable.of();\n        }\n        return new Observable(function (observer) {\n            var syncQueriesSubscription;\n            _this.runningProcesses.isOpen &&\n                _this.runningProcesses.add(function (onTerminate) { return __awaiter(_this, void 0, void 0, function () {\n                    var terminated, _loop_1, this_1;\n                    var _this = this;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                terminated = false;\n                                _loop_1 = function () {\n                                    var count, modelLastSync, paginatingModels, newestFullSyncStartedAt, theInterval, start, duration, newestStartedAt, msNextFullSync;\n                                    return __generator(this, function (_a) {\n                                        switch (_a.label) {\n                                            case 0:\n                                                count = new WeakMap();\n                                                return [4 /*yield*/, this_1.getModelsMetadataWithNextFullSync(Date.now())];\n                                            case 1:\n                                                modelLastSync = _a.sent();\n                                                paginatingModels = new Set(modelLastSync.keys());\n                                                return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                                        if (!_this.runningProcesses.isOpen)\n                                                            resolve();\n                                                        onTerminate.then(function () { return resolve(); });\n                                                        syncQueriesSubscription = _this.syncQueriesProcessor\n                                                            .start(modelLastSync)\n                                                            .subscribe({\n                                                            next: function (_a) {\n                                                                var namespace = _a.namespace, modelDefinition = _a.modelDefinition, items = _a.items, done = _a.done, startedAt = _a.startedAt, isFullSync = _a.isFullSync;\n                                                                return __awaiter(_this, void 0, void 0, function () {\n                                                                    var modelConstructor, modelName, modelMetadata_1, lastFullSync, fullSyncInterval, counts;\n                                                                    var _this = this;\n                                                                    return __generator(this, function (_b) {\n                                                                        switch (_b.label) {\n                                                                            case 0:\n                                                                                modelConstructor = this.userModelClasses[modelDefinition.name];\n                                                                                if (!count.has(modelConstructor)) {\n                                                                                    count.set(modelConstructor, {\n                                                                                        new: 0,\n                                                                                        updated: 0,\n                                                                                        deleted: 0,\n                                                                                    });\n                                                                                    start = getNow();\n                                                                                    newestStartedAt =\n                                                                                        newestStartedAt === undefined\n                                                                                            ? startedAt\n                                                                                            : Math.max(newestStartedAt, startedAt);\n                                                                                }\n                                                                                /**\n                                                                                 * If there are mutations in the outbox for a given id, those need to be\n                                                                                 * merged individually. Otherwise, we can merge them in batches.\n                                                                                 */\n                                                                                return [4 /*yield*/, this.storage.runExclusive(function (storage) { return __awaiter(_this, void 0, void 0, function () {\n                                                                                        var idsInOutbox, oneByOne, page, opTypeCount, oneByOne_1, oneByOne_1_1, item, opType, e_1_1, _a, _b, _c, counts;\n                                                                                        var e_1, _d;\n                                                                                        return __generator(this, function (_e) {\n                                                                                            switch (_e.label) {\n                                                                                                case 0: return [4 /*yield*/, this.outbox.getModelIds(storage)];\n                                                                                                case 1:\n                                                                                                    idsInOutbox = _e.sent();\n                                                                                                    oneByOne = [];\n                                                                                                    page = items.filter(function (item) {\n                                                                                                        var itemId = getIdentifierValue(modelDefinition, item);\n                                                                                                        if (!idsInOutbox.has(itemId)) {\n                                                                                                            return true;\n                                                                                                        }\n                                                                                                        oneByOne.push(item);\n                                                                                                        return false;\n                                                                                                    });\n                                                                                                    opTypeCount = [];\n                                                                                                    _e.label = 2;\n                                                                                                case 2:\n                                                                                                    _e.trys.push([2, 7, 8, 9]);\n                                                                                                    oneByOne_1 = __values(oneByOne), oneByOne_1_1 = oneByOne_1.next();\n                                                                                                    _e.label = 3;\n                                                                                                case 3:\n                                                                                                    if (!!oneByOne_1_1.done) return [3 /*break*/, 6];\n                                                                                                    item = oneByOne_1_1.value;\n                                                                                                    return [4 /*yield*/, this.modelMerger.merge(storage, item, modelDefinition)];\n                                                                                                case 4:\n                                                                                                    opType = _e.sent();\n                                                                                                    if (opType !== undefined) {\n                                                                                                        opTypeCount.push([item, opType]);\n                                                                                                    }\n                                                                                                    _e.label = 5;\n                                                                                                case 5:\n                                                                                                    oneByOne_1_1 = oneByOne_1.next();\n                                                                                                    return [3 /*break*/, 3];\n                                                                                                case 6: return [3 /*break*/, 9];\n                                                                                                case 7:\n                                                                                                    e_1_1 = _e.sent();\n                                                                                                    e_1 = { error: e_1_1 };\n                                                                                                    return [3 /*break*/, 9];\n                                                                                                case 8:\n                                                                                                    try {\n                                                                                                        if (oneByOne_1_1 && !oneByOne_1_1.done && (_d = oneByOne_1.return)) _d.call(oneByOne_1);\n                                                                                                    }\n                                                                                                    finally { if (e_1) throw e_1.error; }\n                                                                                                    return [7 /*endfinally*/];\n                                                                                                case 9:\n                                                                                                    _b = (_a = opTypeCount.push).apply;\n                                                                                                    _c = [opTypeCount];\n                                                                                                    return [4 /*yield*/, this.modelMerger.mergePage(storage, modelConstructor, page, modelDefinition)];\n                                                                                                case 10:\n                                                                                                    _b.apply(_a, _c.concat([__spread.apply(void 0, [(_e.sent())])]));\n                                                                                                    counts = count.get(modelConstructor);\n                                                                                                    opTypeCount.forEach(function (_a) {\n                                                                                                        var _b = __read(_a, 2), opType = _b[1];\n                                                                                                        switch (opType) {\n                                                                                                            case OpType.INSERT:\n                                                                                                                counts.new++;\n                                                                                                                break;\n                                                                                                            case OpType.UPDATE:\n                                                                                                                counts.updated++;\n                                                                                                                break;\n                                                                                                            case OpType.DELETE:\n                                                                                                                counts.deleted++;\n                                                                                                                break;\n                                                                                                            default:\n                                                                                                                exhaustiveCheck(opType);\n                                                                                                        }\n                                                                                                    });\n                                                                                                    return [2 /*return*/];\n                                                                                            }\n                                                                                        });\n                                                                                    }); })];\n                                                                            case 1:\n                                                                                /**\n                                                                                 * If there are mutations in the outbox for a given id, those need to be\n                                                                                 * merged individually. Otherwise, we can merge them in batches.\n                                                                                 */\n                                                                                _b.sent();\n                                                                                if (!done) return [3 /*break*/, 4];\n                                                                                modelName = modelDefinition.name;\n                                                                                return [4 /*yield*/, this.getModelMetadata(namespace, modelName)];\n                                                                            case 2:\n                                                                                modelMetadata_1 = _b.sent();\n                                                                                lastFullSync = modelMetadata_1.lastFullSync, fullSyncInterval = modelMetadata_1.fullSyncInterval;\n                                                                                theInterval = fullSyncInterval;\n                                                                                newestFullSyncStartedAt =\n                                                                                    newestFullSyncStartedAt === undefined\n                                                                                        ? lastFullSync\n                                                                                        : Math.max(newestFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                                                                                modelMetadata_1 = this.modelClasses\n                                                                                    .ModelMetadata.copyOf(modelMetadata_1, function (draft) {\n                                                                                    draft.lastSync = startedAt;\n                                                                                    draft.lastFullSync = isFullSync\n                                                                                        ? startedAt\n                                                                                        : modelMetadata_1.lastFullSync;\n                                                                                });\n                                                                                return [4 /*yield*/, this.storage.save(modelMetadata_1, undefined, ownSymbol)];\n                                                                            case 3:\n                                                                                _b.sent();\n                                                                                counts = count.get(modelConstructor);\n                                                                                this.modelSyncedStatus.set(modelConstructor, true);\n                                                                                observer.next({\n                                                                                    type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                                                                                    data: {\n                                                                                        model: modelConstructor,\n                                                                                        isFullSync: isFullSync,\n                                                                                        isDeltaSync: !isFullSync,\n                                                                                        counts: counts,\n                                                                                    },\n                                                                                });\n                                                                                paginatingModels.delete(modelDefinition);\n                                                                                if (paginatingModels.size === 0) {\n                                                                                    duration = getNow() - start;\n                                                                                    resolve();\n                                                                                    observer.next({\n                                                                                        type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY,\n                                                                                    });\n                                                                                    syncQueriesSubscription.unsubscribe();\n                                                                                }\n                                                                                _b.label = 4;\n                                                                            case 4: return [2 /*return*/];\n                                                                        }\n                                                                    });\n                                                                });\n                                                            },\n                                                            error: function (error) {\n                                                                observer.error(error);\n                                                            },\n                                                        });\n                                                        observer.next({\n                                                            type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n                                                            data: {\n                                                                models: Array.from(paginatingModels).map(function (_a) {\n                                                                    var name = _a.name;\n                                                                    return name;\n                                                                }),\n                                                            },\n                                                        });\n                                                    })];\n                                            case 2:\n                                                _a.sent();\n                                                msNextFullSync = newestFullSyncStartedAt +\n                                                    theInterval -\n                                                    (newestStartedAt + duration);\n                                                logger.debug(\"Next fullSync in \" + msNextFullSync / 1000 + \" seconds. (\" + new Date(Date.now() + msNextFullSync) + \")\");\n                                                // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                                                // a lot of thought into what that contract looks like to\n                                                //  support possible use-cases:\n                                                //\n                                                //  1. non-cancelable\n                                                //  2. cancelable, unsleep on exit()\n                                                //  3. cancelable, throw Error on exit()\n                                                //  4. cancelable, callback first on exit()?\n                                                //  5. ... etc. ? ...\n                                                //\n                                                // TLDR; this is a lot of complexity here for a sleep(),\n                                                // but, it's not clear to me yet how to support an\n                                                // extensible, centralized cancelable `sleep()` elegantly.\n                                                return [4 /*yield*/, this_1.runningProcesses.add(function (onTerminate) { return __awaiter(_this, void 0, void 0, function () {\n                                                        var sleepTimer, unsleep, sleep;\n                                                        return __generator(this, function (_a) {\n                                                            sleep = new Promise(function (_unsleep) {\n                                                                unsleep = _unsleep;\n                                                                sleepTimer = setTimeout(unsleep, msNextFullSync);\n                                                            });\n                                                            onTerminate.then(function () {\n                                                                terminated = true;\n                                                                unsleep();\n                                                            });\n                                                            return [2 /*return*/, sleep];\n                                                        });\n                                                    }); }, 'syncQueriesObservable sleep')];\n                                            case 3:\n                                                // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                                                // a lot of thought into what that contract looks like to\n                                                //  support possible use-cases:\n                                                //\n                                                //  1. non-cancelable\n                                                //  2. cancelable, unsleep on exit()\n                                                //  3. cancelable, throw Error on exit()\n                                                //  4. cancelable, callback first on exit()?\n                                                //  5. ... etc. ? ...\n                                                //\n                                                // TLDR; this is a lot of complexity here for a sleep(),\n                                                // but, it's not clear to me yet how to support an\n                                                // extensible, centralized cancelable `sleep()` elegantly.\n                                                _a.sent();\n                                                return [2 /*return*/];\n                                        }\n                                    });\n                                };\n                                this_1 = this;\n                                _a.label = 1;\n                            case 1:\n                                if (!(!observer.closed && !terminated)) return [3 /*break*/, 3];\n                                return [5 /*yield**/, _loop_1()];\n                            case 2:\n                                _a.sent();\n                                return [3 /*break*/, 1];\n                            case 3: return [2 /*return*/];\n                        }\n                    });\n                }); }, 'syncQueriesObservable main');\n        });\n    };\n    SyncEngine.prototype.disconnectionHandler = function () {\n        var _this = this;\n        return function (msg) {\n            // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n            if (PUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg ||\n                PUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg) {\n                _this.datastoreConnectivity.socketDisconnected();\n            }\n        };\n    };\n    SyncEngine.prototype.unsubscribeConnectivity = function () {\n        this.datastoreConnectivity.unsubscribe();\n    };\n    /**\n     * Stops all subscription activities and resolves when all activies report\n     * that they're disconnected, done retrying, etc..\n     */\n    SyncEngine.prototype.stop = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        logger.debug('stopping sync engine');\n                        /**\n                         * Gracefully disconnecting subscribers first just prevents *more* work\n                         * from entering the pipelines.\n                         */\n                        this.unsubscribeConnectivity();\n                        /**\n                         * aggressively shut down any lingering background processes.\n                         * some of this might be semi-redundant with unsubscribing. however,\n                         * unsubscribing doesn't allow us to wait for settling.\n                         * (Whereas `stop()` does.)\n                         */\n                        return [4 /*yield*/, this.mutationsProcessor.stop()];\n                    case 1:\n                        /**\n                         * aggressively shut down any lingering background processes.\n                         * some of this might be semi-redundant with unsubscribing. however,\n                         * unsubscribing doesn't allow us to wait for settling.\n                         * (Whereas `stop()` does.)\n                         */\n                        _a.sent();\n                        return [4 /*yield*/, this.subscriptionsProcessor.stop()];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.datastoreConnectivity.stop()];\n                    case 3:\n                        _a.sent();\n                        return [4 /*yield*/, this.syncQueriesProcessor.stop()];\n                    case 4:\n                        _a.sent();\n                        return [4 /*yield*/, this.runningProcesses.close()];\n                    case 5:\n                        _a.sent();\n                        return [4 /*yield*/, this.runningProcesses.open()];\n                    case 6:\n                        _a.sent();\n                        logger.debug('sync engine stopped and ready to restart');\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SyncEngine.prototype.setupModels = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fullSyncInterval, ModelMetadataConstructor, models, savedModel, promises, result, _a, _b, modelMetadata, modelName, e_2_1;\n            var e_2, _c;\n            var _this = this;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        fullSyncInterval = params.fullSyncInterval;\n                        ModelMetadataConstructor = this.modelClasses\n                            .ModelMetadata;\n                        models = [];\n                        Object.values(this.schema.namespaces).forEach(function (namespace) {\n                            Object.values(namespace.models)\n                                .filter(function (_a) {\n                                var syncable = _a.syncable;\n                                return syncable;\n                            })\n                                .forEach(function (model) {\n                                models.push([namespace.name, model]);\n                                if (namespace.name === USER) {\n                                    var modelConstructor = _this.userModelClasses[model.name];\n                                    _this.modelSyncedStatus.set(modelConstructor, false);\n                                }\n                            });\n                        });\n                        promises = models.map(function (_a) {\n                            var _b = __read(_a, 2), namespace = _b[0], model = _b[1];\n                            return __awaiter(_this, void 0, void 0, function () {\n                                var modelMetadata, syncPredicate, lastSyncPredicate, prevSyncPredicate, syncPredicateUpdated_1;\n                                var _c, _d, _e, _f;\n                                return __generator(this, function (_g) {\n                                    switch (_g.label) {\n                                        case 0: return [4 /*yield*/, this.getModelMetadata(namespace, model.name)];\n                                        case 1:\n                                            modelMetadata = _g.sent();\n                                            syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n                                            lastSyncPredicate = syncPredicate\n                                                ? JSON.stringify(syncPredicate)\n                                                : null;\n                                            if (!(modelMetadata === undefined)) return [3 /*break*/, 3];\n                                            return [4 /*yield*/, this.storage.save(this.modelInstanceCreator(ModelMetadataConstructor, {\n                                                    model: model.name,\n                                                    namespace: namespace,\n                                                    lastSync: null,\n                                                    fullSyncInterval: fullSyncInterval,\n                                                    lastFullSync: null,\n                                                    lastSyncPredicate: lastSyncPredicate,\n                                                }), undefined, ownSymbol)];\n                                        case 2:\n                                            _c = __read.apply(void 0, [_g.sent(), 1]), _d = __read(_c[0], 1), savedModel = _d[0];\n                                            return [3 /*break*/, 5];\n                                        case 3:\n                                            prevSyncPredicate = modelMetadata.lastSyncPredicate\n                                                ? modelMetadata.lastSyncPredicate\n                                                : null;\n                                            syncPredicateUpdated_1 = prevSyncPredicate !== lastSyncPredicate;\n                                            return [4 /*yield*/, this.storage.save(ModelMetadataConstructor.copyOf(modelMetadata, function (draft) {\n                                                    draft.fullSyncInterval = fullSyncInterval;\n                                                    // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n                                                    // ensures that the local store contains all the data specified by the syncExpression\n                                                    if (syncPredicateUpdated_1) {\n                                                        draft.lastSync = null;\n                                                        draft.lastFullSync = null;\n                                                        draft.lastSyncPredicate = lastSyncPredicate;\n                                                    }\n                                                }))];\n                                        case 4:\n                                            _e = __read.apply(void 0, [_g.sent(), 1]), _f = __read(_e[0], 1), savedModel = _f[0];\n                                            _g.label = 5;\n                                        case 5: return [2 /*return*/, savedModel];\n                                    }\n                                });\n                            });\n                        });\n                        result = {};\n                        _d.label = 1;\n                    case 1:\n                        _d.trys.push([1, 6, 7, 8]);\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        _a = __values.apply(void 0, [_d.sent()]), _b = _a.next();\n                        _d.label = 3;\n                    case 3:\n                        if (!!_b.done) return [3 /*break*/, 5];\n                        modelMetadata = _b.value;\n                        modelName = modelMetadata.model;\n                        result[modelName] = modelMetadata;\n                        _d.label = 4;\n                    case 4:\n                        _b = _a.next();\n                        return [3 /*break*/, 3];\n                    case 5: return [3 /*break*/, 8];\n                    case 6:\n                        e_2_1 = _d.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 8];\n                    case 7:\n                        try {\n                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                        return [7 /*endfinally*/];\n                    case 8: return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    SyncEngine.prototype.getModelsMetadata = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var ModelMetadata, modelsMetadata;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ModelMetadata = this.modelClasses\n                            .ModelMetadata;\n                        return [4 /*yield*/, this.storage.query(ModelMetadata)];\n                    case 1:\n                        modelsMetadata = _a.sent();\n                        return [2 /*return*/, modelsMetadata];\n                }\n            });\n        });\n    };\n    SyncEngine.prototype.getModelMetadata = function (namespace, model) {\n        return __awaiter(this, void 0, void 0, function () {\n            var ModelMetadata, predicate, _a, modelMetadata;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        ModelMetadata = this.modelClasses\n                            .ModelMetadata;\n                        predicate = ModelPredicateCreator.createFromExisting(this.schema.namespaces[SYNC].models[ModelMetadata.name], function (c) { return c.namespace('eq', namespace).model('eq', model); });\n                        return [4 /*yield*/, this.storage.query(ModelMetadata, predicate, {\n                                page: 0,\n                                limit: 1,\n                            })];\n                    case 1:\n                        _a = __read.apply(void 0, [_b.sent(), 1]), modelMetadata = _a[0];\n                        return [2 /*return*/, modelMetadata];\n                }\n            });\n        });\n    };\n    SyncEngine.prototype.getModelDefinition = function (modelConstructor) {\n        var namespaceName = this.namespaceResolver(modelConstructor);\n        var modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n        return modelDefinition;\n    };\n    SyncEngine.getNamespace = function () {\n        var namespace = {\n            name: SYNC,\n            relationships: {},\n            enums: {\n                OperationType: {\n                    name: 'OperationType',\n                    values: ['CREATE', 'UPDATE', 'DELETE'],\n                },\n            },\n            nonModels: {},\n            models: {\n                MutationEvent: {\n                    name: 'MutationEvent',\n                    pluralName: 'MutationEvents',\n                    syncable: false,\n                    fields: {\n                        id: {\n                            name: 'id',\n                            type: 'ID',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        model: {\n                            name: 'model',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        data: {\n                            name: 'data',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        modelId: {\n                            name: 'modelId',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        operation: {\n                            name: 'operation',\n                            type: {\n                                enum: 'Operationtype',\n                            },\n                            isArray: false,\n                            isRequired: true,\n                        },\n                        condition: {\n                            name: 'condition',\n                            type: 'String',\n                            isArray: false,\n                            isRequired: true,\n                        },\n                    },\n                },\n                ModelMetadata: {\n                    name: 'ModelMetadata',\n                    pluralName: 'ModelsMetadata',\n                    syncable: false,\n                    fields: {\n                        id: {\n                            name: 'id',\n                            type: 'ID',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        namespace: {\n                            name: 'namespace',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        model: {\n                            name: 'model',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        lastSync: {\n                            name: 'lastSync',\n                            type: 'Int',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                        lastFullSync: {\n                            name: 'lastFullSync',\n                            type: 'Int',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                        fullSyncInterval: {\n                            name: 'fullSyncInterval',\n                            type: 'Int',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        lastSyncPredicate: {\n                            name: 'lastSyncPredicate',\n                            type: 'String',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                    },\n                },\n            },\n        };\n        return namespace;\n    };\n    return SyncEngine;\n}());\nexport { SyncEngine };\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}