{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport warning from 'tiny-warning';\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n/**\n * Convert nested rules to separate, remove them from original styles.\n */\n\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container, sheet) {\n    return function (match, key) {\n      var rule = container.getRule(key) || sheet && sheet.getRule(key);\n      if (rule) {\n        return rule.selector;\n      }\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Could not find the referenced rule \\\"\" + key + \"\\\" in \\\"\" + (container.options.meta || container.toString()) + \"\\\".\") : void 0;\n      return key;\n    };\n  }\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n    var result = '';\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.\n\n        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + \" \" + nested;\n      }\n    }\n    return result;\n  }\n  function getOptions(rule, container, prevOptions) {\n    // Options has been already created, now we only increase index.\n    if (prevOptions) return _extends({}, prevOptions, {\n      index: prevOptions.index + 1\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n    var options = _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.\n    });\n\n    delete options.name;\n    return options;\n  }\n  function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style') return style;\n    var styleRule = rule;\n    var container = styleRule.options.parent;\n    var options;\n    var replaceRef;\n    for (var prop in style) {\n      var isNested = prop.indexOf('&') !== -1;\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(styleRule, container, options);\n      if (isNested) {\n        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n\n        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.\n\n        selector = selector.replace(refRegExp, replaceRef);\n        var name = styleRule.key + \"-\" + prop;\n        if ('replaceRule' in container) {\n          // for backward compatibility\n          container.replaceRule(name, style[prop], _extends({}, options, {\n            selector: selector\n          }));\n        } else {\n          container.addRule(name, style[prop], _extends({}, options, {\n            selector: selector\n          }));\n        }\n      } else if (isNestedConditional) {\n        // Place conditional right after the parent rule to ensure right ordering.\n        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {\n          selector: styleRule.selector\n        });\n      }\n      delete style[prop];\n    }\n    return style;\n  }\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}\nexport default jssNested;","map":{"version":3,"names":["_extends","warning","separatorRegExp","parentRegExp","refRegExp","jssNested","getReplaceRef","container","sheet","match","key","rule","getRule","selector","process","env","NODE_ENV","options","meta","toString","replaceParentRefs","nestedProp","parentProp","parentSelectors","split","nestedSelectors","result","i","length","parent","j","nested","indexOf","replace","getOptions","prevOptions","index","nestingLevel","undefined","name","onProcessStyle","style","type","styleRule","replaceRef","prop","isNested","isNestedConditional","replaceRule","addRule"],"sources":["F:/project/front-end/hei-admin-ui/node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport warning from 'tiny-warning';\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n/**\n * Convert nested rules to separate, remove them from original styles.\n */\n\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container, sheet) {\n    return function (match, key) {\n      var rule = container.getRule(key) || sheet && sheet.getRule(key);\n\n      if (rule) {\n        return rule.selector;\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Could not find the referenced rule \\\"\" + key + \"\\\" in \\\"\" + (container.options.meta || container.toString()) + \"\\\".\") : void 0;\n      return key;\n    };\n  }\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.\n\n        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + \" \" + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, prevOptions) {\n    // Options has been already created, now we only increase index.\n    if (prevOptions) return _extends({}, prevOptions, {\n      index: prevOptions.index + 1\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    var options = _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.\n\n    });\n\n    delete options.name;\n    return options;\n  }\n\n  function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style') return style;\n    var styleRule = rule;\n    var container = styleRule.options.parent;\n    var options;\n    var replaceRef;\n\n    for (var prop in style) {\n      var isNested = prop.indexOf('&') !== -1;\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(styleRule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n\n        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.\n\n        selector = selector.replace(refRegExp, replaceRef);\n        var name = styleRule.key + \"-\" + prop;\n\n        if ('replaceRule' in container) {\n          // for backward compatibility\n          container.replaceRule(name, style[prop], _extends({}, options, {\n            selector: selector\n          }));\n        } else {\n          container.addRule(name, style[prop], _extends({}, options, {\n            selector: selector\n          }));\n        }\n      } else if (isNestedConditional) {\n        // Place conditional right after the parent rule to ensure right ordering.\n        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {\n          selector: styleRule.selector\n        });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}\n\nexport default jssNested;\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAOC,OAAO,MAAM,cAAc;AAElC,IAAIC,eAAe,GAAG,UAAU;AAChC,IAAIC,YAAY,GAAG,IAAI;AACvB,IAAIC,SAAS,GAAG,aAAa;AAC7B;AACA;AACA;;AAEA,SAASC,SAAS,GAAG;EACnB;EACA,SAASC,aAAa,CAACC,SAAS,EAAEC,KAAK,EAAE;IACvC,OAAO,UAAUC,KAAK,EAAEC,GAAG,EAAE;MAC3B,IAAIC,IAAI,GAAGJ,SAAS,CAACK,OAAO,CAACF,GAAG,CAAC,IAAIF,KAAK,IAAIA,KAAK,CAACI,OAAO,CAACF,GAAG,CAAC;MAEhE,IAAIC,IAAI,EAAE;QACR,OAAOA,IAAI,CAACE,QAAQ;MACtB;MAEAC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGf,OAAO,CAAC,KAAK,EAAE,6CAA6C,GAAGS,GAAG,GAAG,UAAU,IAAIH,SAAS,CAACU,OAAO,CAACC,IAAI,IAAIX,SAAS,CAACY,QAAQ,EAAE,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC;MAC5L,OAAOT,GAAG;IACZ,CAAC;EACH;EAEA,SAASU,iBAAiB,CAACC,UAAU,EAAEC,UAAU,EAAE;IACjD,IAAIC,eAAe,GAAGD,UAAU,CAACE,KAAK,CAACtB,eAAe,CAAC;IACvD,IAAIuB,eAAe,GAAGJ,UAAU,CAACG,KAAK,CAACtB,eAAe,CAAC;IACvD,IAAIwB,MAAM,GAAG,EAAE;IAEf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,eAAe,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;MAC/C,IAAIE,MAAM,GAAGN,eAAe,CAACI,CAAC,CAAC;MAE/B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,eAAe,CAACG,MAAM,EAAEE,CAAC,EAAE,EAAE;QAC/C,IAAIC,MAAM,GAAGN,eAAe,CAACK,CAAC,CAAC;QAC/B,IAAIJ,MAAM,EAAEA,MAAM,IAAI,IAAI,CAAC,CAAC;;QAE5BA,MAAM,IAAIK,MAAM,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAGD,MAAM,CAACE,OAAO,CAAC9B,YAAY,EAAE0B,MAAM,CAAC,GAAGA,MAAM,GAAG,GAAG,GAAGE,MAAM;MACrG;IACF;IAEA,OAAOL,MAAM;EACf;EAEA,SAASQ,UAAU,CAACvB,IAAI,EAAEJ,SAAS,EAAE4B,WAAW,EAAE;IAChD;IACA,IAAIA,WAAW,EAAE,OAAOnC,QAAQ,CAAC,CAAC,CAAC,EAAEmC,WAAW,EAAE;MAChDC,KAAK,EAAED,WAAW,CAACC,KAAK,GAAG;IAC7B,CAAC,CAAC;IACF,IAAIC,YAAY,GAAG1B,IAAI,CAACM,OAAO,CAACoB,YAAY;IAC5CA,YAAY,GAAGA,YAAY,KAAKC,SAAS,GAAG,CAAC,GAAGD,YAAY,GAAG,CAAC;IAEhE,IAAIpB,OAAO,GAAGjB,QAAQ,CAAC,CAAC,CAAC,EAAEW,IAAI,CAACM,OAAO,EAAE;MACvCoB,YAAY,EAAEA,YAAY;MAC1BD,KAAK,EAAE7B,SAAS,CAACyB,OAAO,CAACrB,IAAI,CAAC,GAAG,CAAC,CAAC;IAErC,CAAC,CAAC;;IAEF,OAAOM,OAAO,CAACsB,IAAI;IACnB,OAAOtB,OAAO;EAChB;EAEA,SAASuB,cAAc,CAACC,KAAK,EAAE9B,IAAI,EAAEH,KAAK,EAAE;IAC1C,IAAIG,IAAI,CAAC+B,IAAI,KAAK,OAAO,EAAE,OAAOD,KAAK;IACvC,IAAIE,SAAS,GAAGhC,IAAI;IACpB,IAAIJ,SAAS,GAAGoC,SAAS,CAAC1B,OAAO,CAACY,MAAM;IACxC,IAAIZ,OAAO;IACX,IAAI2B,UAAU;IAEd,KAAK,IAAIC,IAAI,IAAIJ,KAAK,EAAE;MACtB,IAAIK,QAAQ,GAAGD,IAAI,CAACb,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;MACvC,IAAIe,mBAAmB,GAAGF,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG;MACzC,IAAI,CAACC,QAAQ,IAAI,CAACC,mBAAmB,EAAE;MACvC9B,OAAO,GAAGiB,UAAU,CAACS,SAAS,EAAEpC,SAAS,EAAEU,OAAO,CAAC;MAEnD,IAAI6B,QAAQ,EAAE;QACZ,IAAIjC,QAAQ,GAAGO,iBAAiB,CAACyB,IAAI,EAAEF,SAAS,CAAC9B,QAAQ,CAAC,CAAC,CAAC;QAC5D;;QAEA,IAAI,CAAC+B,UAAU,EAAEA,UAAU,GAAGtC,aAAa,CAACC,SAAS,EAAEC,KAAK,CAAC,CAAC,CAAC;;QAE/DK,QAAQ,GAAGA,QAAQ,CAACoB,OAAO,CAAC7B,SAAS,EAAEwC,UAAU,CAAC;QAClD,IAAIL,IAAI,GAAGI,SAAS,CAACjC,GAAG,GAAG,GAAG,GAAGmC,IAAI;QAErC,IAAI,aAAa,IAAItC,SAAS,EAAE;UAC9B;UACAA,SAAS,CAACyC,WAAW,CAACT,IAAI,EAAEE,KAAK,CAACI,IAAI,CAAC,EAAE7C,QAAQ,CAAC,CAAC,CAAC,EAAEiB,OAAO,EAAE;YAC7DJ,QAAQ,EAAEA;UACZ,CAAC,CAAC,CAAC;QACL,CAAC,MAAM;UACLN,SAAS,CAAC0C,OAAO,CAACV,IAAI,EAAEE,KAAK,CAACI,IAAI,CAAC,EAAE7C,QAAQ,CAAC,CAAC,CAAC,EAAEiB,OAAO,EAAE;YACzDJ,QAAQ,EAAEA;UACZ,CAAC,CAAC,CAAC;QACL;MACF,CAAC,MAAM,IAAIkC,mBAAmB,EAAE;QAC9B;QACAxC,SAAS,CAAC0C,OAAO,CAACJ,IAAI,EAAE,CAAC,CAAC,EAAE5B,OAAO,CAAC,CAACgC,OAAO,CAACN,SAAS,CAACjC,GAAG,EAAE+B,KAAK,CAACI,IAAI,CAAC,EAAE;UACvEhC,QAAQ,EAAE8B,SAAS,CAAC9B;QACtB,CAAC,CAAC;MACJ;MAEA,OAAO4B,KAAK,CAACI,IAAI,CAAC;IACpB;IAEA,OAAOJ,KAAK;EACd;EAEA,OAAO;IACLD,cAAc,EAAEA;EAClB,CAAC;AACH;AAEA,eAAenC,SAAS"},"metadata":{},"sourceType":"module"}