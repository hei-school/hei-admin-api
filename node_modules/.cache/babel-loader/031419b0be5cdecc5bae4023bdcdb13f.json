{"ast":null,"code":"import { __values } from \"tslib\";\nimport { fromHex, toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { Int64 } from \"./Int64\";\n/**\n * @internal\n */\nvar HeaderMarshaller = /** @class */function () {\n  function HeaderMarshaller(toUtf8, fromUtf8) {\n    this.toUtf8 = toUtf8;\n    this.fromUtf8 = fromUtf8;\n  }\n  HeaderMarshaller.prototype.format = function (headers) {\n    var e_1, _a, e_2, _b;\n    var chunks = [];\n    try {\n      for (var _c = __values(Object.keys(headers)), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var headerName = _d.value;\n        var bytes = this.fromUtf8(headerName);\n        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    var out = new Uint8Array(chunks.reduce(function (carry, bytes) {\n      return carry + bytes.byteLength;\n    }, 0));\n    var position = 0;\n    try {\n      for (var chunks_1 = __values(chunks), chunks_1_1 = chunks_1.next(); !chunks_1_1.done; chunks_1_1 = chunks_1.next()) {\n        var chunk = chunks_1_1.value;\n        out.set(chunk, position);\n        position += chunk.byteLength;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (chunks_1_1 && !chunks_1_1.done && (_b = chunks_1.return)) _b.call(chunks_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return out;\n  };\n  HeaderMarshaller.prototype.formatHeaderValue = function (header) {\n    switch (header.type) {\n      case \"boolean\":\n        return Uint8Array.from([header.value ? 0 /* boolTrue */ : 1 /* boolFalse */]);\n      case \"byte\":\n        return Uint8Array.from([2 /* byte */, header.value]);\n      case \"short\":\n        var shortView = new DataView(new ArrayBuffer(3));\n        shortView.setUint8(0, 3 /* short */);\n        shortView.setInt16(1, header.value, false);\n        return new Uint8Array(shortView.buffer);\n      case \"integer\":\n        var intView = new DataView(new ArrayBuffer(5));\n        intView.setUint8(0, 4 /* integer */);\n        intView.setInt32(1, header.value, false);\n        return new Uint8Array(intView.buffer);\n      case \"long\":\n        var longBytes = new Uint8Array(9);\n        longBytes[0] = 5 /* long */;\n        longBytes.set(header.value.bytes, 1);\n        return longBytes;\n      case \"binary\":\n        var binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n        binView.setUint8(0, 6 /* byteArray */);\n        binView.setUint16(1, header.value.byteLength, false);\n        var binBytes = new Uint8Array(binView.buffer);\n        binBytes.set(header.value, 3);\n        return binBytes;\n      case \"string\":\n        var utf8Bytes = this.fromUtf8(header.value);\n        var strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n        strView.setUint8(0, 7 /* string */);\n        strView.setUint16(1, utf8Bytes.byteLength, false);\n        var strBytes = new Uint8Array(strView.buffer);\n        strBytes.set(utf8Bytes, 3);\n        return strBytes;\n      case \"timestamp\":\n        var tsBytes = new Uint8Array(9);\n        tsBytes[0] = 8 /* timestamp */;\n        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n        return tsBytes;\n      case \"uuid\":\n        if (!UUID_PATTERN.test(header.value)) {\n          throw new Error(\"Invalid UUID received: \" + header.value);\n        }\n        var uuidBytes = new Uint8Array(17);\n        uuidBytes[0] = 9 /* uuid */;\n        uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n        return uuidBytes;\n    }\n  };\n  HeaderMarshaller.prototype.parse = function (headers) {\n    var out = {};\n    var position = 0;\n    while (position < headers.byteLength) {\n      var nameLength = headers.getUint8(position++);\n      var name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n      position += nameLength;\n      switch (headers.getUint8(position++)) {\n        case 0 /* boolTrue */:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: true\n          };\n          break;\n        case 1 /* boolFalse */:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: false\n          };\n          break;\n        case 2 /* byte */:\n          out[name] = {\n            type: BYTE_TAG,\n            value: headers.getInt8(position++)\n          };\n          break;\n        case 3 /* short */:\n          out[name] = {\n            type: SHORT_TAG,\n            value: headers.getInt16(position, false)\n          };\n          position += 2;\n          break;\n        case 4 /* integer */:\n          out[name] = {\n            type: INT_TAG,\n            value: headers.getInt32(position, false)\n          };\n          position += 4;\n          break;\n        case 5 /* long */:\n          out[name] = {\n            type: LONG_TAG,\n            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))\n          };\n          position += 8;\n          break;\n        case 6 /* byteArray */:\n          var binaryLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: BINARY_TAG,\n            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)\n          };\n          position += binaryLength;\n          break;\n        case 7 /* string */:\n          var stringLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: STRING_TAG,\n            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))\n          };\n          position += stringLength;\n          break;\n        case 8 /* timestamp */:\n          out[name] = {\n            type: TIMESTAMP_TAG,\n            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())\n          };\n          position += 8;\n          break;\n        case 9 /* uuid */:\n          var uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n          position += 16;\n          out[name] = {\n            type: UUID_TAG,\n            value: toHex(uuidBytes.subarray(0, 4)) + \"-\" + toHex(uuidBytes.subarray(4, 6)) + \"-\" + toHex(uuidBytes.subarray(6, 8)) + \"-\" + toHex(uuidBytes.subarray(8, 10)) + \"-\" + toHex(uuidBytes.subarray(10))\n          };\n          break;\n        default:\n          throw new Error(\"Unrecognized header type tag\");\n      }\n    }\n    return out;\n  };\n  return HeaderMarshaller;\n}();\nexport { HeaderMarshaller };\nvar HEADER_VALUE_TYPE;\n(function (HEADER_VALUE_TYPE) {\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolTrue\"] = 0] = \"boolTrue\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolFalse\"] = 1] = \"boolFalse\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byte\"] = 2] = \"byte\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"short\"] = 3] = \"short\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"integer\"] = 4] = \"integer\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"long\"] = 5] = \"long\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byteArray\"] = 6] = \"byteArray\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"string\"] = 7] = \"string\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"timestamp\"] = 8] = \"timestamp\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"uuid\"] = 9] = \"uuid\";\n})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));\nvar BOOLEAN_TAG = \"boolean\";\nvar BYTE_TAG = \"byte\";\nvar SHORT_TAG = \"short\";\nvar INT_TAG = \"integer\";\nvar LONG_TAG = \"long\";\nvar BINARY_TAG = \"binary\";\nvar STRING_TAG = \"string\";\nvar TIMESTAMP_TAG = \"timestamp\";\nvar UUID_TAG = \"uuid\";\nvar UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;","map":{"version":3,"sources":["../../src/HeaderMarshaller.ts"],"names":[],"mappings":"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","sourcesContent":["import { Decoder, Encoder, MessageHeaders, MessageHeaderValue } from \"@aws-sdk/types\";\nimport { fromHex, toHex } from \"@aws-sdk/util-hex-encoding\";\n\nimport { Int64 } from \"./Int64\";\n\n/**\n * @internal\n */\nexport class HeaderMarshaller {\n  constructor(private readonly toUtf8: Encoder, private readonly fromUtf8: Decoder) {}\n\n  format(headers: MessageHeaders): Uint8Array {\n    const chunks: Array<Uint8Array> = [];\n\n    for (const headerName of Object.keys(headers)) {\n      const bytes = this.fromUtf8(headerName);\n      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n    }\n\n    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));\n    let position = 0;\n    for (const chunk of chunks) {\n      out.set(chunk, position);\n      position += chunk.byteLength;\n    }\n\n    return out;\n  }\n\n  private formatHeaderValue(header: MessageHeaderValue): Uint8Array {\n    switch (header.type) {\n      case \"boolean\":\n        return Uint8Array.from([header.value ? HEADER_VALUE_TYPE.boolTrue : HEADER_VALUE_TYPE.boolFalse]);\n      case \"byte\":\n        return Uint8Array.from([HEADER_VALUE_TYPE.byte, header.value]);\n      case \"short\":\n        const shortView = new DataView(new ArrayBuffer(3));\n        shortView.setUint8(0, HEADER_VALUE_TYPE.short);\n        shortView.setInt16(1, header.value, false);\n        return new Uint8Array(shortView.buffer);\n      case \"integer\":\n        const intView = new DataView(new ArrayBuffer(5));\n        intView.setUint8(0, HEADER_VALUE_TYPE.integer);\n        intView.setInt32(1, header.value, false);\n        return new Uint8Array(intView.buffer);\n      case \"long\":\n        const longBytes = new Uint8Array(9);\n        longBytes[0] = HEADER_VALUE_TYPE.long;\n        longBytes.set(header.value.bytes, 1);\n        return longBytes;\n      case \"binary\":\n        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n        binView.setUint8(0, HEADER_VALUE_TYPE.byteArray);\n        binView.setUint16(1, header.value.byteLength, false);\n        const binBytes = new Uint8Array(binView.buffer);\n        binBytes.set(header.value, 3);\n        return binBytes;\n      case \"string\":\n        const utf8Bytes = this.fromUtf8(header.value);\n        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n        strView.setUint8(0, HEADER_VALUE_TYPE.string);\n        strView.setUint16(1, utf8Bytes.byteLength, false);\n        const strBytes = new Uint8Array(strView.buffer);\n        strBytes.set(utf8Bytes, 3);\n        return strBytes;\n      case \"timestamp\":\n        const tsBytes = new Uint8Array(9);\n        tsBytes[0] = HEADER_VALUE_TYPE.timestamp;\n        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n        return tsBytes;\n      case \"uuid\":\n        if (!UUID_PATTERN.test(header.value)) {\n          throw new Error(`Invalid UUID received: ${header.value}`);\n        }\n\n        const uuidBytes = new Uint8Array(17);\n        uuidBytes[0] = HEADER_VALUE_TYPE.uuid;\n        uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n        return uuidBytes;\n    }\n  }\n\n  parse(headers: DataView): MessageHeaders {\n    const out: MessageHeaders = {};\n    let position = 0;\n\n    while (position < headers.byteLength) {\n      const nameLength = headers.getUint8(position++);\n      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n      position += nameLength;\n\n      switch (headers.getUint8(position++)) {\n        case HEADER_VALUE_TYPE.boolTrue:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: true,\n          };\n          break;\n        case HEADER_VALUE_TYPE.boolFalse:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: false,\n          };\n          break;\n        case HEADER_VALUE_TYPE.byte:\n          out[name] = {\n            type: BYTE_TAG,\n            value: headers.getInt8(position++),\n          };\n          break;\n        case HEADER_VALUE_TYPE.short:\n          out[name] = {\n            type: SHORT_TAG,\n            value: headers.getInt16(position, false),\n          };\n          position += 2;\n          break;\n        case HEADER_VALUE_TYPE.integer:\n          out[name] = {\n            type: INT_TAG,\n            value: headers.getInt32(position, false),\n          };\n          position += 4;\n          break;\n        case HEADER_VALUE_TYPE.long:\n          out[name] = {\n            type: LONG_TAG,\n            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),\n          };\n          position += 8;\n          break;\n        case HEADER_VALUE_TYPE.byteArray:\n          const binaryLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: BINARY_TAG,\n            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),\n          };\n          position += binaryLength;\n          break;\n        case HEADER_VALUE_TYPE.string:\n          const stringLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: STRING_TAG,\n            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),\n          };\n          position += stringLength;\n          break;\n        case HEADER_VALUE_TYPE.timestamp:\n          out[name] = {\n            type: TIMESTAMP_TAG,\n            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),\n          };\n          position += 8;\n          break;\n        case HEADER_VALUE_TYPE.uuid:\n          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n          position += 16;\n          out[name] = {\n            type: UUID_TAG,\n            value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(\n              uuidBytes.subarray(6, 8)\n            )}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`,\n          };\n          break;\n        default:\n          throw new Error(`Unrecognized header type tag`);\n      }\n    }\n\n    return out;\n  }\n}\n\nconst enum HEADER_VALUE_TYPE {\n  boolTrue = 0,\n  boolFalse,\n  byte,\n  short,\n  integer,\n  long,\n  byteArray,\n  string,\n  timestamp,\n  uuid,\n}\n\nconst BOOLEAN_TAG = \"boolean\";\nconst BYTE_TAG = \"byte\";\nconst SHORT_TAG = \"short\";\nconst INT_TAG = \"integer\";\nconst LONG_TAG = \"long\";\nconst BINARY_TAG = \"binary\";\nconst STRING_TAG = \"string\";\nconst TIMESTAMP_TAG = \"timestamp\";\nconst UUID_TAG = \"uuid\";\n\nconst UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}