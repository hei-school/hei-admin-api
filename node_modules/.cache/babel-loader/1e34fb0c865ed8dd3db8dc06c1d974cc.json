{"ast":null,"code":"import { useQuery } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isLoading, error } = useGetOne('users', { id: record.id });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport var useGetOne = function (resource, _a, options) {\n  var id = _a.id,\n    meta = _a.meta;\n  var dataProvider = useDataProvider();\n  return useQuery(\n  // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n  // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n  // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n  [resource, 'getOne', {\n    id: String(id),\n    meta: meta\n  }], function () {\n    return dataProvider.getOne(resource, {\n      id: id,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data;\n      return data;\n    });\n  }, options);\n};","map":{"version":3,"sources":["../../../src/dataProvider/useGetOne.ts"],"names":[],"mappings":"AACA,SAAS,QAAQ,QAAyC,aAAa;AACvE,SAAS,eAAe,QAAQ,mBAAmB;AAEnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCG;AACH,OAAO,IAAM,SAAS,GAAG,UACrB,QAAgB,EAChB,EAAsC,EACtC,OAAqC,EAAA;MADnC,EAAE,GAAA,EAAA,CAAA,EAAA;IAAE,IAAI,GAAA,EAAA,CAAA,IAAA;EAGV,IAAM,YAAY,GAAG,eAAe,EAAE;EACtC,OAAO,QAAQ;EACX;EACA;EACA;EACA,CAAC,QAAQ,EAAE,QAAQ,EAAE;IAAE,EAAE,EAAE,MAAM,CAAC,EAAE,CAAC;IAAE,IAAI,EAAA;EAAA,CAAE,CAAC,EAC9C,YAAA;IACI,OAAA,YAAY,CACP,MAAM,CAAa,QAAQ,EAAE;MAAE,EAAE,EAAA,EAAA;MAAE,IAAI,EAAA;IAAA,CAAE,CAAC,CAC1C,IAAI,CAAC,UAAC,EAAQ,EAAA;UAAN,IAAI,GAAA,EAAA,CAAA,IAAA;MAAO,OAAA,IAAI;IAAJ,CAAI,CAAC;EAF7B,CAE6B,EACjC,OAAO,CACV;AACL,CAAC","sourceRoot":"","sourcesContent":["import { useQuery } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isLoading, error } = useGetOne('users', { id: record.id });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport var useGetOne = function (resource, _a, options) {\n    var id = _a.id, meta = _a.meta;\n    var dataProvider = useDataProvider();\n    return useQuery(\n    // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n    // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n    // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n    [resource, 'getOne', { id: String(id), meta: meta }], function () {\n        return dataProvider\n            .getOne(resource, { id: id, meta: meta })\n            .then(function (_a) {\n            var data = _a.data;\n            return data;\n        });\n    }, options);\n};\n//# sourceMappingURL=useGetOne.js.map"]},"metadata":{},"sourceType":"module"}